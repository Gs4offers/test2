<#=====================================================================
 Parallel File-Copy Engine – PowerShell 5.1
=====================================================================#>

# -------------------------- 1. CONFIGURATION --------------------------
$maxNumberOfParallelJobs = 3 * [Environment]::ProcessorCount # I/O bound → 2× cores is usually best
$onlyVerifyDestinationFile = $false
$overwriteIfDestinationExists = $false

$inputFilesFolder = "C:\Users\B296SD\OneDrive - AXA\Projects\Health\Sapphire\InputFiles\28Oct2025"
$sourceRootFolder = "\\nscnvf11.axa-icas.net\axisdocs\assigned"
$destinationRootFolder = "\\nscnvf11.axa-icas.net\Archive\Docs_20Oct2025"
$scriptLogFileFolder = "C:\temp\ScriptLogsVerifyRunInputOf28Oct2025"

$startAtFileLine = 1
$numOfFileLinesToProcess = -1 # -1 = whole file

$listOfInputFiles = @(
    'Documents (81).txt'
    ,
    'Documents (58).txt'
    #,
    #'Documents (46).txt'
    #,
    #'Documents (117).txt'
    # add more files here if needed
)

# -------------------------- 2. HELPER FUNCTIONS ----------------------

function New-LogPaths {
    param(
        [string]$Base,
        [string]$AccountId,
        [string]$AccountName,
        [int]$StartLine
    )
    $ts = Get-Date -Format "yyyyMMdd_HHmmss"
    return @(
        "$Base\Session_$ts.txt",
        "$Base\Script_$AccountName-$AccountId-$StartLine.txt",
        "$Base\Extract_$AccountName-$AccountId-$StartLine.txt"
    )
}

function Get-AccountInfo ([string[]]$line) {
    $id = $line[0].Trim('"')
    $name = $line[1].Trim('"') -replace '[\<\>\:"/\\\|\?\*~]', '_'
    return $id, $name
}

##function Resolve-Paths ([string]$srcFull, [string]$srcRoot, [string]$dstRoot, [string]$docID) {
##    $src = $srcFull.Trim('"')
##    $dst = $src -replace ([regex]::Escape($srcRoot)), $dstRoot
##    if ($dst -eq $src) { return $null, $null }
##    return $src, $dst
##}

function Get-PooledPowershellInstance {
    param([System.Collections.Concurrent.ConcurrentBag[powershell]] $psPool)

	$ps = $Null
	$null = $psPool.TryTake([ref]$ps)
	$ps.Commands.Clear()
	return $ps
}

# -------------------------- 3. PROCESSING SCRIPTBLOCK ----------------

$scriptBlockForProcessingThread = {
    param(
        $taskID,
        $fileLineNum,
        $docLinkIDWithoutQuotes,
		$sourceRootFolder,
		$destinationRootFolder,
        $sourceFileFullPath,
        $onlyVerifyDestinationFile,
        $overwriteIfDestinationExists
    )

    $fileCopied = 0; $sourceFileMissing = 0; $destAlreadyExists = 0; $copyFailed = 0
    $logString = ""
	
	$sourcePath = .substring(0, $sourceFileFullPath.LastIndexOf('\'))

	$sourceFileName = $sourceFileFullPath.substring($sourceFileFullPath.LastIndexOf('\')+1)

	if($sourceFileName.LastIndexOf('.') -ge 0) {

		$fileExtension = $sourceFileName.Substring($sourceFileName.LastIndexOf('.'))
	}
	else {

		$fileExtension = ''
	}

	$destinationFileFullPath = $sourceFileFullPath -replace ([regex]::Escape($sourceRootFolder)), $destinationRootFolder
	
	$destinationFolderPath = $destinationFileFullPath.substring(0, $destinationFileFullPath.LastIndexOf('\'))

	$destinationFileFullPath = "$destinationFolderPath\$docLinkIDWithoutQuotes$fileExtension"

    # ---- valid destination? ----
    if ($destinationFileFullPath -eq $sourceFileFullPath) {
        $copyFailed = 1
        $logString = "Fileline#: $fileLineNum : Task: $taskID : DocID: $docLinkIDWithoutQuotes : InvalidDestinationPath: $destinationFileFullPath"
        return @{
            TaskID = $taskID; DocID = $docLinkIDWithoutQuotes; SourceFileFullPath = $sourceFileFullPath
            DestinationFileFullPath = $destinationFileFullPath; FileCopied = $fileCopied
            SourceFileMissing = $sourceFileMissing; DestAlreadyExists = $destAlreadyExists; CopyFailed = $copyFailed
            LogString = "$(get-date -format "ddMMyyyy_HHmmss.ffff") : $($logString)"
        }
    }
	
    # ---- source exists? ----
    if ((!(Test-Path -LiteralPath $sourceFileFullPath)) -and (!(Test-Path -Path $sourceFileFullPath))) {
        $sourceFileMissing = 1
        $logString = "Fileline#: $fileLineNum : Task: $taskID : DocID: $docLinkIDWithoutQuotes : SourceFileMissing: $sourceFileFullPath"
        return @{
            TaskID = $taskID; DocID = $docLinkIDWithoutQuotes; SourceFileFullPath = $sourceFileFullPath
            DestinationFileFullPath = $destinationFileFullPath; FileCopied = $fileCopied
            SourceFileMissing = $sourceFileMissing; DestAlreadyExists = $destAlreadyExists; CopyFailed = $copyFailed
            LogString = "$(get-date -format "ddMMyyyy_HHmmss.ffff") : $($logString)"
        }
    }

    # ---- create destination folder ----
    $destDir = [IO.Path]::GetDirectoryName($destinationFileFullPath)
    if (-not (Test-Path -LiteralPath $destDir)) {
        try {
            [IO.Directory]::CreateDirectory($destDir) | Out-Null
        } catch {
            $copyFailed = 1
            $logString = "Fileline#: $fileLineNum : Task: $taskID : DocID: $docLinkIDWithoutQuotes : CreateDirFailed: $destDir"
            return @{
                TaskID = $taskID; DocID = $docLinkIDWithoutQuotes; SourceFileFullPath = $sourceFileFullPath
                DestinationFileFullPath = $destinationFileFullPath; FileCopied = $fileCopied
                SourceFileMissing = $sourceFileMissing; DestAlreadyExists = $destAlreadyExists; CopyFailed = $copyFailed
                LogString = "$(get-date -format "ddMMyyyy_HHmmss.ffff") : $($logString)"
            }
        }
    }

    # ---- verify-only mode ----
    if ($onlyVerifyDestinationFile) {
        if (Test-Path -LiteralPath $destinationFileFullPath) {
            $destAlreadyExists = 1
            $logString = "Fileline#: $fileLineNum : Task: $taskID : DocID: $docLinkIDWithoutQuotes : DestAlreadyExists: $destinationFileFullPath"
        } else {
            $copyFailed = 1
            $logString = "Fileline#: $fileLineNum : Task: $taskID : DocID: $docLinkIDWithoutQuotes : CopyFailed: $sourceFileFullPath : IntendedDestination : $destinationFileFullPath" 
        }
        return @{
            TaskID = $taskID; DocID = $docLinkIDWithoutQuotes; SourceFileFullPath = $sourceFileFullPath
            DestinationFileFullPath = $destinationFileFullPath; FileCopied = $fileCopied
            SourceFileMissing = $sourceFileMissing; DestAlreadyExists = $destAlreadyExists; CopyFailed = $copyFailed
            LogString = "$(get-date -format "ddMMyyyy_HHmmss.ffff") : $($logString)"
        }
    }

    # ---- overwrite logic ----
    $destExists = Test-Path -LiteralPath $destinationFileFullPath
    if ($destExists -and -not $overwriteIfDestinationExists) {
        $destAlreadyExists = 1
        $logString = "Fileline#: $fileLineNum : Task: $taskID : DocID: $docLinkIDWithoutQuotes : DestAlreadyExists: $destinationFileFullPath"
        return @{
            TaskID = $taskID; DocID = $docLinkIDWithoutQuotes; SourceFileFullPath = $sourceFileFullPath
            DestinationFileFullPath = $destinationFileFullPath; FileCopied = $fileCopied
            SourceFileMissing = $sourceFileMissing; DestAlreadyExists = $destAlreadyExists; CopyFailed = $copyFailed
            LogString = "$(get-date -format "ddMMyyyy_HHmmss.ffff") : $($logString)"
        }
    }

    # ---- COPY (rename) ----
    try {
        [IO.File]::Copy($sourceFileFullPath, $destinationFileFullPath, $true) # $true = overwrite
        $fileCopied = 1
        $logString = "Fileline#: $fileLineNum : Task: $taskID : DocID: $docLinkIDWithoutQuotes : Copied: $destinationFileFullPath"
    } catch {
        $copyFailed = 1
        $logString = "Fileline#: $fileLineNum : Task: $taskID : DocID: $docLinkIDWithoutQuotes : CopyFailed: $sourceFileFullPath : IntendedDestination : $destinationFileFullPath : $($_.Exception.Message)"
    }

    return @{
        TaskID = $taskID; DocID = $docLinkIDWithoutQuotes; SourceFileFullPath = $sourceFileFullPath
        DestinationFileFullPath = $destinationFileFullPath; FileCopied = $fileCopied
        SourceFileMissing = $sourceFileMissing; DestAlreadyExists = $destAlreadyExists; CopyFailed = $copyFailed
        LogString = "$(get-date -format "ddMMyyyy_HHmmss.ffff") : $($logString)"
    }
}
$processingThreadScriptBlockPrecompiled = [scriptblock]::Create($scriptBlockForProcessingThread.ToString())

# -------------------------- 4. TASK OBJECT ---------------------------

#class CopyTask {
#    [int] $TaskID
#    [int] $FileLineNum
#    [string] $DocID
#    [string] $SourceFileFullPath
#    [string] $DestinationFileFullPath
#    hidden [System.Management.Automation.PowerShell] $Ps
#    hidden [IAsyncResult] $Handle
#    hidden [System.Threading.WaitHandle] $Wait
#
#    CopyTask($id, $ln, $doc, $src, $dst, $ps) {
#        $this.TaskID = $id
#        $this.FileLineNum = $ln
#        $this.DocID = $doc
#        $this.SourceFileFullPath = $src
#        $this.DestinationFileFullPath = $dst
#        $this.Ps = $ps
#        $this.Handle = $ps.BeginInvoke()
#        $this.Wait = $this.Handle.AsyncWaitHandle
#    }
#
#    [bool] IsReady() { return $this.Wait.WaitOne(0) }
#    [hashtable] Collect() {
#        $result = $this.Ps.EndInvoke($this.Handle)
#        $this.Ps.Dispose()
#        return $result
#    }
#}

# -------------------------- 5. WORKER POOL ---------------------------
$sharedBag = [System.Collections.Concurrent.ConcurrentBag[hashtable]]::new()
$logQueue = [System.Collections.Concurrent.ConcurrentQueue[string]]::new()

$syncObjProcessorToDisposer = [hashtable]::Synchronized(@{ Done = $false })
$syncObjDisposerToLogger = [hashtable]::Synchronized(@{ Done = $false })

$throttleSemaphore = [System.Threading.SemaphoreSlim]::new($maxNumberOfParallelJobs, $maxNumberOfParallelJobs)


$processorRunspacePool = [runspacefactory]::CreateRunspacePool(1, $maxNumberOfParallelJobs)
$processorRunspacePool.Open()

$powershellPoolForProcessor = [System.Collections.Concurrent.ConcurrentBag[powershell]]::new()
$maxPowershellInstances = $maxNumberOfParallelJobs * 2 #a bit more than actual thread count
1..$maxPowershellInstances | ForEach-Object{
	$ps = [powershell]::Create()
	$ps.RunspacePool = $processorRunspacePool
	$powershellPoolForProcessor.add($ps)
}


$DisposerRunspacePool = [runspacefactory]::CreateRunspacePool(1, 1)
$DisposerRunspacePool.Open()
$disposerScriptBlock = {
    param($bag, $q, $sync, $psPool, $throttleSemaphore)

    while (-not $sync.Done -or $bag.Count -gt 0) {
        $task = $null
        if ($bag.TryTake([ref]$task)) {

            if ($task.Handle.AsyncWaitHandle.WaitOne(0)) {
                try {
                    $r = $task.Ps.EndInvoke($task.Handle)
                    $q.Enqueue($r.LogString)
                    # optional: update shared counters here
                } 
                catch {
                    $q.Enqueue("EndInvoke Error: $($_.Exception.Message)")
                } 
                finally {
                    $task.Ps.Dispose()
                    $task.Ps.Commands.Clear()
                    $psPool.Add($task.Ps)
                    $throttleSemaphore.Release()
                }
            } 
            else {

                $bag.Add($task)
                Start-Sleep -Milliseconds 10
            }
        } 
        else {
            Start-Sleep -Milliseconds 30

        }
    }
}
$disposerScriptBlockPreCompiled = [scriptblock]::Create($disposerScriptBlock.ToString())

$loggerRunspacePool = [runspacefactory]::CreateRunspacePool(1, 1)
$loggerRunspacePool.Open()

$loggerScriptBlock = {
    param($queue, $file, $sync)
    "Started logging" | Out-File -FilePath $file
    while (-not $sync.Done -or $queue.Count -gt 0) {
        $msg = $null
        if ($queue.TryDequeue([ref]$msg)) {
            $msg | Out-File -FilePath $file -Append
        } else {
            Start-Sleep -Milliseconds 10
        }
    }
}
$loggerScriptBlockPreCompiled = [scriptblock]::Create($loggerScriptBlock.ToString())


# -------------------------- 8. PROGRESS BAR -------------------------

#class ProgressBar {
#    [int] $Total = 0
#    [int] $Copied = 0
#    [string] $CurrentFile = ""
#    [System.Threading.Timer] $Timer
#
#    ProgressBar([int]$total) {
#        $this.Total = $total
#        $this.Timer = [System.Threading.Timer]::new(
#            {
#                param($state)
#                $p = $state
#                $pct = if ($p.Total -gt 0) { [math]::Round($p.Copied * 100 / $p.Total, 1) } else { 0 }
#                $bar = '=' * [int]($pct / 2) + ' ' * (50 - [int]($pct / 2))
#                $line = "$($p.CurrentFile.PadRight(30).Substring(0, [math]::Min(30, $p.CurrentFile.Length))) | [$bar] $pct% | Copied: $($p.Copied)/$($p.Total)"
#                Write-Host "`r$line" -NoNewline
#            },
#            $this,
#            [TimeSpan]::FromMilliseconds(100),
#            [TimeSpan]::FromMilliseconds(100)
#        )
#    }
#
#    [void] Update([string]$file, [int]$copied) {
#        $this.CurrentFile = [IO.Path]::GetFileName($file)
#        $this.Copied = $copied
#    }
#
#    [void] Stop() {
#        $this.Timer.Dispose()
#        Write-Host "`nProgress complete."
#    }
#}

# -------------------------- 9. MAIN ---------------------------------

try {
    # ---- create log folder ----
    if (-not (Test-Path $scriptLogFileFolder)) {
        New-Item -ItemType Directory -Path $scriptLogFileFolder -Force | Out-Null
    }

    # ---- pre-count total lines for progress bar ----
    $totalLinesToProcess = 0
    foreach ($f in $listOfInputFiles) {
        $p = Join-Path $inputFilesFolder $f
        $c = (Get-Content $p).Count
        $lines = if ($numOfFileLinesToProcess -eq -1) { $c } else { [math]::Min($numOfFileLinesToProcess, $c) }
        $start = [math]::Max(0, $startAtFileLine - 1)
        $totalLinesToProcess += ($lines - $start)
    }
    #$progress = [ProgressBar]::new($totalLinesToProcess)

    # ---- session-level variables ----
    $sessionTotalCopied = 0
    $sessionTotalMissing = 0
    $sessionTotalExists = 0
    $sessionTotalFailed = 0
    $sessionTotalSkipped = 0
    $sessionTotalLong = 0

    foreach ($currInputFile in $listOfInputFiles) {
    Write-Host ">>>> $($currInputFile)"

        $syncObjProcessorToDisposer.Done = $false

        $accountDocListFilePath = Join-Path $inputFilesFolder $currInputFile
        $fileContent = Get-Content $accountDocListFilePath

        $linesToProcess = if ($numOfFileLinesToProcess -eq -1) { $fileContent.Count } else { [math]::Min($numOfFileLinesToProcess, $fileContent.Count) }
        $startIdx = [math]::Max(0, $startAtFileLine - 1)

        $firstLine = $fileContent[1] -split '\|'
        $accountID, $accountName = Get-AccountInfo $firstLine

        # Generate log paths
        $sessionLogFileFullPath, $scriptLogFileFullPath, $extractLogFileFullPath = New-LogPaths $scriptLogFileFolder $accountID $accountName $startIdx

        #start disposer for this account
        # -------------------------- 6. DISPOSER (zero-CPU) -------------------

        $disposerPs = [powershell]::Create()
        $disposerPs.RunspacePool = $DisposerRunspacePool
        $disposerPs.AddScript($disposerScriptBlock).AddArgument($sharedBag).AddArgument($logQueue).AddArgument($syncObjProcessorToDisposer).AddArgument($powershellPoolForProcessor).AddArgument($throttleSemaphore) | Out-Null
        $disposerHandle = $disposerPs.BeginInvoke()


        # start logger for this account
        # -------------------------- 7. LOGGER (zero-CPU) -------------------
        $syncObjDisposerToLogger.Done = $false
        $loggerPs = [powershell]::Create().AddScript($loggerScriptBlock)
        $loggerPs.RunspacePool = $loggerRunspacePool
        $loggerPs.AddArgument($logQueue).AddArgument($extractLogFileFullPath).AddArgument($syncObjDisposerToLogger) | Out-Null
        $loggerHandle = $loggerPs.BeginInvoke()
        
        # account-level counters
        $totalCopied = 0
        $totalSourceFileMissing = 0
        $totalDestAlreadyExists = 0
        $totalCopyFailed = 0
        $totalInvalidFileLinesSkipped = 0
        $totalSourcePathTooLong = 0

        $seenDocIds = @{}

        write-host "# of lines: $($linesToProcess)"

        for ($i = $startIdx; $i -lt $linesToProcess; $i++) {

            # Progress update every 50 tasks
            if (($i + 1) % 1000 -eq 0) { 
                #$progress.Update($currInputFile, $sessionTotalCopied) 
                write-host "Processing Line#: $($i+1)"
            }

            $splittedCurrFileLine = $fileContent[$i] -split '\|'
            if ($splittedCurrFileLine[0].Trim('"') -eq 'accountid') {
                $totalInvalidFileLinesSkipped++
                continue
            }

            $sourceFileFullPath = $splittedCurrFileLine[8]
            if (-not $sourceFileFullPath.ToLower().Contains('assigned')) {
                $totalInvalidFileLinesSkipped++
                continue
            }

            $sourceFileFullPath = $sourceFileFullPath.Trim('"')
            $docLinkIDWithoutQuotes = $splittedCurrFileLine[10].Trim('"')

            #$src, $dst = Resolve-Paths $sourceFileFullPath $sourceRootFolder $destinationRootFolder $docLinkIDWithoutQuotes
            #if (-not $src) {
            #    $totalInvalidFileLinesSkipped++
            #    continue
            #}


            if ($seenDocIds.ContainsKey($docLinkIDWithoutQuotes)) {
                $totalDestAlreadyExists++
                continue
            }
            $seenDocIds[$docLinkIDWithoutQuotes] = $true

            if ($src.Length -gt 259) {
                $totalSourcePathTooLong++
                continue
            }

            write-host "Before semaphore: # of tasks running: $($sharedBag.Count)"

			#Throttle if needed
			$throttleSemaphore.Wait() #blocks if no free semaphore

            write-host "After semaphore: # of tasks running: $($sharedBag.Count)"
			
            # Submit task
            #$ps = [powershell]::Create().AddScript($scriptBlockForProcessingThread)
            #$ps.RunspacePool = $processorRunspacePool
            $ps = Get-PooledPowershellInstance -psPool $powershellPoolForProcessor
            $ps.AddScript($processingThreadScriptBlockPrecompiled).AddArgument($i + 1).AddArgument($i + 1).AddArgument($docLinkIDWithoutQuotes).AddArgument($sourceRootFolder).AddArgument($destinationRootFolder).AddArgument($sourceFileFullPath).AddArgument($onlyVerifyDestinationFile).AddArgument($overwriteIfDestinationExists) | Out-Null
            $handle = $ps.BeginInvoke()

            $taskObj = @{
                Ps = $ps
                Handle = $handle
                TaskID = "$($i + 1)-$($currInputFile)"
                FileLineNum = $i + 1
                DocID = $docLinkIDWithoutQuotes
                SourceFileFullPath = $src
                DestinationFileFullPath = $dst
            }

            $sharedBag.Add($taskObj)

            write-host "# of tasks running: $($sharedBag.Count)"

            # Throttle if needed
            #while ($sharedBag.Count -ge $maxNumberOfParallelJobs) { 
            #    Start-Sleep -Milliseconds 10; 
            #    #write-host "Waiting for some tasks to finish: $($sharedBag.Count)" 
            #}

            #write-host "# of tasks running: $($sharedBag.Count)"
 
        }

        write-host "finished all lines in file. # of tasks running: $($sharedBag.Count)"

        # Signal disposer to finish
        $syncObjProcessorToDisposer.Done = $true
        $null = $disposerPs.EndInvoke($disposerHandle); 
	    $disposerPs.Dispose()

        write-host "disposed disposer. # of tasks running: $($sharedBag.Count)"

        $syncObjDisposerToLogger.Done = $true
        $null = $loggerPs.EndInvoke($loggerHandle); 
		$loggerPs.Dispose()

        write-host "disposed logger. # of tasks running: $($sharedBag.Count)"

        # Final progress update
        #$progress.Update($currInputFile, $sessionTotalCopied)

        # Session summary
        $acctMsg = "Totals:: LinesInFile: $numOfFileLinesToProcess : Invalid file lines skipped: $totalInvalidFileLinesSkipped : Total files processed: $($totalCopied + $totalSourceFileMissing + $totalDestAlreadyExists + $totalSourcePathTooLong) : TotalCopied: $totalCopied : TotalSourceFileMissing: $totalSourceFileMissing : TotalDestAlreadyExists: $totalDestAlreadyExists : TotalSourcePathTooLong: $totalSourcePathTooLong : TotalCopyFailed: $totalCopyFailed"
        $acctMsg | Out-File $scriptLogFileFullPath -Append
        $acctMsg | Out-File $sessionLogFileFullPath -Append

        # Accumulate session totals
        $sessionTotalCopied += $totalCopied
        $sessionTotalMissing += $totalSourceFileMissing
        $sessionTotalExists += $totalDestAlreadyExists
        $sessionTotalFailed += $totalCopyFailed
        $sessionTotalSkipped += $totalInvalidFileLinesSkipped
        $sessionTotalLong += $totalSourcePathTooLong

        write-host "..... going to next file. # of tasks running: $($sharedBag.Count)"
    }

    #$progress.Stop()
    $final = "Session Totals:: Invalid file lines skipped: $sessionTotalInvalidFileLinesSkipped : Total files processed: $($sessionTotalCopied + $sessionTotalSourceFileMissing + $sessionTotalDestAlreadyExists + $sessionTotalSourcePathTooLong) : TotalCopied: $sessionTotalCopied : TotalSourceFileMissing: $sessionTotalSourceFileMissing : TotalDestAlreadyExists: $sessionTotalDestAlreadyExists : TotalSourcePathTooLong: $sessionTotalSourcePathTooLong  : TotalCopyFailed: $sessionTotalFailed"
    $final | Out-File $sessionLogFileFullPath -Append
    Write-Host $final
}
catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    $_.Exception | Format-List * -Force | Out-String | Out-File "$scriptLogFileFolder\Error_$(Get-Date -Format yyyyMMdd_HHmmss).txt"
}
finally {
    # ---- cleanup ----
    if ($disposerPs) { $disposerPs.Dispose() }
    if ($loggerPs) { $loggerPs.Dispose() }
    if ($processorRunspacePool) { $processorRunspacePool.Close(); $processorRunspacePool.Dispose() }
    if ($loggerRunspacePool) { $loggerRunspacePool.Close(); $loggerRunspacePool.Dispose() }
    
    "Cleanup complete – $(Get-Date)" | Out-File $sessionLogFileFullPath -Append
}
